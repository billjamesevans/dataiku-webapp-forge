import io
import json
import os
import re
import zipfile
import pprint
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from jinja2 import Environment, FileSystemLoader, select_autoescape


def _slug(value: str) -> str:
    value = (value or "").strip().lower()
    value = re.sub(r"[^a-z0-9]+", "-", value).strip("-")
    return value or "webapp"


@dataclass(frozen=True)
class GeneratedApp:
    slug: str
    title: str
    files: Dict[str, str]  # path -> content


def _env(templates_dir: str) -> Environment:
    env = Environment(
        loader=FileSystemLoader(templates_dir),
        autoescape=select_autoescape(enabled_extensions=("html", "xml")),
        trim_blocks=True,
        lstrip_blocks=True,
    )
    # Keep templates simple: allow emitting JSON and Python literals explicitly.
    def _tojson(obj: Any, indent: Optional[int] = None) -> str:
        # Deterministic JSON output helps diffs and reduces noisy regen churn.
        return json.dumps(obj, indent=indent, ensure_ascii=True, sort_keys=True)

    def _py(obj: Any) -> str:
        return pprint.pformat(obj, width=120, sort_dicts=True)

    env.filters["tojson"] = _tojson
    env.filters["py"] = _py
    return env


def build_apps(project: Dict[str, Any], *, templates_dir: str) -> List[GeneratedApp]:
    env = _env(templates_dir)

    base_name = (project.get("app") or {}).get("name") or "Simple Dataiku WebApp"
    subtitle = (project.get("app") or {}).get("subtitle") or ""
    dataiku_cfg = project.get("dataiku") or {}
    transform = project.get("transform") or {}
    ui_cfg = project.get("ui") or {}

    cols_all = [c for c in (transform.get("columns") or []) if isinstance(c, dict) and c.get("name")]
    computed = transform.get("computed_columns") if isinstance(transform.get("computed_columns"), list) else []
    for cc in computed:
        if not isinstance(cc, dict):
            continue
        name = cc.get("name")
        if not name:
            continue
        # Computed columns become selectable output columns.
        cols_all.append(
            {
                "name": str(name),
                "label": str(cc.get("label") or name),
                "include": bool(cc.get("include")),
                "source": "computed",
            }
        )

    # Apply explicit output ordering if provided.
    order = transform.get("output_order") if isinstance(transform.get("output_order"), list) else []
    by_name = {c.get("name"): c for c in cols_all if c.get("name")}
    cols_selected = [c for c in cols_all if c.get("include")]
    if order:
        ordered = [by_name[n] for n in order if n in by_name and by_name[n].get("include")]
        rest = [c for c in cols_selected if c.get("name") not in set(order)]
        cols_selected = ordered + rest
    if not cols_selected:
        cols_selected = cols_all

    common_ctx = {
        "app_name": base_name,
        "subtitle": subtitle,
        "dataiku": dataiku_cfg,
        "project": project,
        "transform": transform,
        "ui": ui_cfg,
        "columns_selected": cols_selected,
    }

    apps: List[GeneratedApp] = []

    slug = _slug(base_name) or "webapp"
    files: Dict[str, str] = {}
    for tpl_name, out_name in [
        ("webapp/index.html.j2", "index.html"),
        ("webapp/style.css.j2", "style.css"),
        ("webapp/script.js.j2", "script.js"),
        ("webapp/backend.py.j2", "backend.py"),
        ("webapp/requirements.txt.j2", "requirements.txt"),
        ("webapp/SETUP.md.j2", "SETUP.md"),
        ("webapp/app_config.json.j2", "app_config.json"),
    ]:
        tpl = env.get_template(tpl_name)
        files[out_name] = tpl.render(**common_ctx)
    apps.append(GeneratedApp(slug=slug, title=base_name, files=files))

    return apps


def build_zip_bytes(project: Dict[str, Any], *, templates_dir: str) -> bytes:
    apps = build_apps(project, templates_dir=templates_dir)
    mem = io.BytesIO()
    with zipfile.ZipFile(mem, "w", compression=zipfile.ZIP_DEFLATED) as zf:
        # Top-level README in the export bundle.
        readme = (
            "# Dataiku WebApp Export\\n\\n"
            "This zip was generated by `dataiku_webapp_forge`.\\n\\n"
            "Each subfolder is a Dataiku Standard WebApp. In Dataiku, create a new Standard WebApp and add the files\\n"
            "from the chosen folder: `index.html` (body-only), `style.css`, `script.js`, `backend.py`.\\n\\n"
            "See each folder's `SETUP.md` for the exact dataset/schema expectations.\\n"
        )
        zf.writestr("README.md", readme)

        for app in apps:
            base = app.slug + "/"
            for path, content in app.files.items():
                zf.writestr(base + path, content)
    return mem.getvalue()
